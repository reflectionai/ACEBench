"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Protobuf definition for the trace."""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.internal.extension_dict
import google.protobuf.message
import google.protobuf.struct_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _Role:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _RoleEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Role.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNSPECIFIED: _Role.ValueType  # 0
    USER: _Role.ValueType  # 1
    ASSISTANT: _Role.ValueType  # 2
    SYSTEM: _Role.ValueType  # 3
    VALUE: _Role.ValueType  # 4

class Role(_Role, metaclass=_RoleEnumTypeWrapper):
    """The role of a message."""

UNSPECIFIED: Role.ValueType  # 0
USER: Role.ValueType  # 1
ASSISTANT: Role.ValueType  # 2
SYSTEM: Role.ValueType  # 3
VALUE: Role.ValueType  # 4
global___Role = Role

@typing.final
class Token(google.protobuf.message.Message):
    """/////////// Sampling ////////////"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Tag:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _TagEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Token._Tag.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        MESSAGE_HEADER: Token._Tag.ValueType  # 0
        """A header describing the role of the message."""
        MESSAGE_CONTENT: Token._Tag.ValueType  # 1
        """The content of a non-inference message."""
        MESSAGE_EOT: Token._Tag.ValueType  # 2
        """The end of a non-inference message."""
        TRACE_HEADER: Token._Tag.ValueType  # 3
        """Header sections showing where the trace begins (and sometimes ends)."""
        TRACE_MESSAGES: Token._Tag.ValueType  # 4
        """The messages in the trace."""

    class Tag(_Tag, metaclass=_TagEnumTypeWrapper): ...
    MESSAGE_HEADER: Token.Tag.ValueType  # 0
    """A header describing the role of the message."""
    MESSAGE_CONTENT: Token.Tag.ValueType  # 1
    """The content of a non-inference message."""
    MESSAGE_EOT: Token.Tag.ValueType  # 2
    """The end of a non-inference message."""
    TRACE_HEADER: Token.Tag.ValueType  # 3
    """Header sections showing where the trace begins (and sometimes ends)."""
    TRACE_MESSAGES: Token.Tag.ValueType  # 4
    """The messages in the trace."""

    TOKEN_ID_FIELD_NUMBER: builtins.int
    TOKEN_STR_FIELD_NUMBER: builtins.int
    TAGS_FIELD_NUMBER: builtins.int
    token_id: builtins.int
    """The token ID."""
    token_str: builtins.str
    """A string representation of the token."""
    @property
    def tags(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The tags associated with the token."""

    def __init__(
        self,
        *,
        token_id: builtins.int | None = ...,
        token_str: builtins.str | None = ...,
        tags: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["token_id", b"token_id", "token_str", b"token_str"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["tags", b"tags", "token_id", b"token_id", "token_str", b"token_str"]) -> None: ...

global___Token = Token

@typing.final
class Logprob(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TOKEN_FIELD_NUMBER: builtins.int
    LOGPROB_FIELD_NUMBER: builtins.int
    logprob: builtins.float
    """The logprob for the token."""
    @property
    def token(self) -> global___Token:
        """The token."""

    def __init__(
        self,
        *,
        token: global___Token | None = ...,
        logprob: builtins.float | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["logprob", b"logprob", "token", b"token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["logprob", b"logprob", "token", b"token"]) -> None: ...

global___Logprob = Logprob

@typing.final
class SampledToken(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SELECTED_TOKEN_FIELD_NUMBER: builtins.int
    LOGPROBS_FIELD_NUMBER: builtins.int
    @property
    def selected_token(self) -> global___Token:
        """The token."""

    @property
    def logprobs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Logprob]:
        """The logprobs for the token."""

    def __init__(
        self,
        *,
        selected_token: global___Token | None = ...,
        logprobs: collections.abc.Iterable[global___Logprob] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["selected_token", b"selected_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["logprobs", b"logprobs", "selected_token", b"selected_token"]) -> None: ...

global___SampledToken = SampledToken

@typing.final
class SamplingInfo(google.protobuf.message.Message):
    """Information about a sampling event."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INPUT_TOKENS_FIELD_NUMBER: builtins.int
    OUTPUT_TOKENS_FIELD_NUMBER: builtins.int
    @property
    def input_tokens(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Token]:
        """The tokenized input."""

    @property
    def output_tokens(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SampledToken]:
        """The sampled output tokens each with their top-k logprobs."""

    def __init__(
        self,
        *,
        input_tokens: collections.abc.Iterable[global___Token] | None = ...,
        output_tokens: collections.abc.Iterable[global___SampledToken] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["input_tokens", b"input_tokens", "output_tokens", b"output_tokens"]) -> None: ...

global___SamplingInfo = SamplingInfo

@typing.final
class ValueSamplingArguments(google.protobuf.message.Message):
    """Arguments for sampling a value."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MIN_VALUE_FIELD_NUMBER: builtins.int
    MAX_VALUE_FIELD_NUMBER: builtins.int
    min_value: builtins.float
    """The minimum value to sample from."""
    max_value: builtins.float
    """The maximum value to sample from."""
    def __init__(
        self,
        *,
        min_value: builtins.float | None = ...,
        max_value: builtins.float | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["max_value", b"max_value", "min_value", b"min_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["max_value", b"max_value", "min_value", b"min_value"]) -> None: ...

global___ValueSamplingArguments = ValueSamplingArguments

@typing.final
class SamplingArguments(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TEMPERATURE_FIELD_NUMBER: builtins.int
    TOP_P_FIELD_NUMBER: builtins.int
    MAX_TOKENS_FIELD_NUMBER: builtins.int
    VALUE_SAMPLING_ARGS_FIELD_NUMBER: builtins.int
    SKIP_SPECIAL_TOKENS_FIELD_NUMBER: builtins.int
    NUM_PROMPT_LOGPROBS_FIELD_NUMBER: builtins.int
    NUM_LOGPROBS_FIELD_NUMBER: builtins.int
    TRUNCATE_INPUT_FIELD_NUMBER: builtins.int
    temperature: builtins.float
    """The temperature to sample with."""
    top_p: builtins.float
    """The top-p to sample with."""
    max_tokens: builtins.int
    """Maximum number of tokens to sample."""
    skip_special_tokens: builtins.bool
    """Whether to skip special tokens."""
    num_prompt_logprobs: builtins.int
    """The number of prompt logprobs to return."""
    num_logprobs: builtins.int
    """The number of logprobs to return for each sampled token."""
    truncate_input: builtins.int
    """If -1, the input will be truncated to the model's context
    length. If set to 0, no truncation will happen and an error will be returned
    if the input exceeds the model's context length. If set to an integer k,
    will use only the last k tokens from the prompt (i.e., left truncation).
    default: 0
    """
    @property
    def value_sampling_args(self) -> global___ValueSamplingArguments:
        """Optional arguments for value sampling."""

    def __init__(
        self,
        *,
        temperature: builtins.float | None = ...,
        top_p: builtins.float | None = ...,
        max_tokens: builtins.int | None = ...,
        value_sampling_args: global___ValueSamplingArguments | None = ...,
        skip_special_tokens: builtins.bool | None = ...,
        num_prompt_logprobs: builtins.int | None = ...,
        num_logprobs: builtins.int | None = ...,
        truncate_input: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["max_tokens", b"max_tokens", "num_logprobs", b"num_logprobs", "num_prompt_logprobs", b"num_prompt_logprobs", "skip_special_tokens", b"skip_special_tokens", "temperature", b"temperature", "top_p", b"top_p", "truncate_input", b"truncate_input", "value_sampling_args", b"value_sampling_args"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["max_tokens", b"max_tokens", "num_logprobs", b"num_logprobs", "num_prompt_logprobs", b"num_prompt_logprobs", "skip_special_tokens", b"skip_special_tokens", "temperature", b"temperature", "top_p", b"top_p", "truncate_input", b"truncate_input", "value_sampling_args", b"value_sampling_args"]) -> None: ...

global___SamplingArguments = SamplingArguments

@typing.final
class Value(google.protobuf.message.Message):
    """A value message.
    Value messages contain a special value token which corresponds to one of three
    discrete enum values: `ZERO`, `ONE`, and `UNKNOWN`. The first two
    allow using the transformer to predict continuous quantities (e.g., via the
    two-hot distribution RL trick). The `UNKNOWN` value is used to mask out value
    tokens in the input (values are forward-looking, so autoregressive masking
    could otherwise cheat by looking backward).
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _ValueType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ValueTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Value._ValueType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        ZERO: Value._ValueType.ValueType  # 0
        ONE: Value._ValueType.ValueType  # 1
        UNKNOWN: Value._ValueType.ValueType  # 2

    class ValueType(_ValueType, metaclass=_ValueTypeEnumTypeWrapper): ...
    ZERO: Value.ValueType.ValueType  # 0
    ONE: Value.ValueType.ValueType  # 1
    UNKNOWN: Value.ValueType.ValueType  # 2

    VALUE_FIELD_NUMBER: builtins.int
    value: builtins.int
    def __init__(
        self,
        *,
        value: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["value", b"value"]) -> None: ...

global___Value = Value

@typing.final
class Message(google.protobuf.message.Message):
    """A message is the basic unit of a trace."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ROLE_FIELD_NUMBER: builtins.int
    TEXT_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    SAMPLING_INFO_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    REWARD_FIELD_NUMBER: builtins.int
    role: builtins.int
    """The role of the message."""
    text: builtins.str
    reward: builtins.float
    """The reward for the message."""
    @property
    def value(self) -> global___Value: ...
    @property
    def sampling_info(self) -> global___SamplingInfo:
        """The sampling information for the message."""

    @property
    def metadata(self) -> google.protobuf.struct_pb2.Struct:
        """The metadata for the message."""

    def __init__(
        self,
        *,
        role: builtins.int | None = ...,
        text: builtins.str | None = ...,
        value: global___Value | None = ...,
        sampling_info: global___SamplingInfo | None = ...,
        metadata: google.protobuf.struct_pb2.Struct | None = ...,
        reward: builtins.float | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["content", b"content", "metadata", b"metadata", "reward", b"reward", "role", b"role", "sampling_info", b"sampling_info", "text", b"text", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["content", b"content", "metadata", b"metadata", "reward", b"reward", "role", b"role", "sampling_info", b"sampling_info", "text", b"text", "value", b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["content", b"content"]) -> typing.Literal["text", "value"] | None: ...

global___Message = Message

@typing.final
class FinishReasonInfo(google.protobuf.message.Message):
    """Extension for Message providing finish_reason and stop_reason (aligned with vllm/dromeus)"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class StopReason(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        REASON_INT_FIELD_NUMBER: builtins.int
        REASON_STR_FIELD_NUMBER: builtins.int
        reason_int: builtins.int
        reason_str: builtins.str
        def __init__(
            self,
            *,
            reason_int: builtins.int | None = ...,
            reason_str: builtins.str | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["reason", b"reason", "reason_int", b"reason_int", "reason_str", b"reason_str"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["reason", b"reason", "reason_int", b"reason_int", "reason_str", b"reason_str"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["reason", b"reason"]) -> typing.Literal["reason_int", "reason_str"] | None: ...

    FINISH_REASON_FIELD_NUMBER: builtins.int
    STOP_REASON_FIELD_NUMBER: builtins.int
    finish_reason: builtins.str
    """The reason why the sequence is finished."""
    @property
    def stop_reason(self) -> global___FinishReasonInfo.StopReason:
        """The stop string or token id that caused the completion
        to stop, None if the completion finished for some other reason
        including encountering the EOS token.
        """

    def __init__(
        self,
        *,
        finish_reason: builtins.str | None = ...,
        stop_reason: global___FinishReasonInfo.StopReason | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["finish_reason", b"finish_reason", "stop_reason", b"stop_reason"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["finish_reason", b"finish_reason", "stop_reason", b"stop_reason"]) -> None: ...

global___FinishReasonInfo = FinishReasonInfo

@typing.final
class AuxiliaryReward(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    value: builtins.float
    """the auxiliary reward value"""
    def __init__(
        self,
        *,
        value: builtins.float | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["value", b"value"]) -> None: ...

global___AuxiliaryReward = AuxiliaryReward

@typing.final
class Trace(google.protobuf.message.Message):
    """A trace is a collection of messages."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MESSAGES_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    TERMINATED_FIELD_NUMBER: builtins.int
    SAMPLING_ARGUMENTS_FIELD_NUMBER: builtins.int
    terminated: builtins.bool
    """Whether the trace is terminated."""
    @property
    def messages(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Message]:
        """The messages in the trace."""

    @property
    def metadata(self) -> google.protobuf.struct_pb2.Struct:
        """The metadata for the trace."""

    @property
    def sampling_arguments(self) -> global___SamplingArguments:
        """The sampling arguments used for inference"""

    def __init__(
        self,
        *,
        messages: collections.abc.Iterable[global___Message] | None = ...,
        metadata: google.protobuf.struct_pb2.Struct | None = ...,
        terminated: builtins.bool | None = ...,
        sampling_arguments: global___SamplingArguments | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["metadata", b"metadata", "sampling_arguments", b"sampling_arguments", "terminated", b"terminated"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["messages", b"messages", "metadata", b"metadata", "sampling_arguments", b"sampling_arguments", "terminated", b"terminated"]) -> None: ...

global___Trace = Trace

@typing.final
class Metric(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    FLOAT_VALUE_FIELD_NUMBER: builtins.int
    BOOL_VALUE_FIELD_NUMBER: builtins.int
    INT_VALUE_FIELD_NUMBER: builtins.int
    STRING_VALUE_FIELD_NUMBER: builtins.int
    name: builtins.str
    """the name of the metric"""
    float_value: builtins.float
    bool_value: builtins.bool
    int_value: builtins.int
    string_value: builtins.str
    def __init__(
        self,
        *,
        name: builtins.str | None = ...,
        float_value: builtins.float | None = ...,
        bool_value: builtins.bool | None = ...,
        int_value: builtins.int | None = ...,
        string_value: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["bool_value", b"bool_value", "float_value", b"float_value", "int_value", b"int_value", "name", b"name", "string_value", b"string_value", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["bool_value", b"bool_value", "float_value", b"float_value", "int_value", b"int_value", "name", b"name", "string_value", b"string_value", "value", b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["value", b"value"]) -> typing.Literal["float_value", "bool_value", "int_value", "string_value"] | None: ...

global___Metric = Metric

FINISH_REASON_INFO_FIELD_NUMBER: builtins.int
AUXILIARY_REWARD_FIELD_NUMBER: builtins.int
METRICS_FIELD_NUMBER: builtins.int
finish_reason_info: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[global___Message, global___FinishReasonInfo]
auxiliary_reward: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[global___Message, global___AuxiliaryReward]
metrics: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[global___Trace, google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Metric]]
"""metrics about the individual messages in the trace"""
